Алгоритм Бентли-Оттмана

Входными данными для алгоритма является коллекция линейных отрезков L(i...n), а выходными - набор точек их пересечений I(j...k). Алгоритм часто называют "выметающей прямой", поскольку его выполнение можно визуализировать с помощью прямой SL, движущейся по коллекции отрезков L и обрабатывающей информацию об отрезках. В каждом своем положении прямая SL хранит упорядоченный список отрезков, который она в данный момент пересекает. Этот список зачастую также называют "выметающей прямой". Кроме хранения, структура, которая содержит отрезки, находит и выводит их пересечения. Процесс нахождения пересечений и составляет ядро алгоритма и залог его эффективности.

Перед реализацией алгоритма необходимо сперва линейно упорядочить отрезки L(i...n) для того, чтобы определить порядок, в котором их будет проходить выметающая прямая SL. Это означает, что необходимо упорядочить конечные точки всех отрезков, чтобы определить моменты, когда SL начинает и заканчивает пересекать отрезок. Чаще всего, точки упорядочивают по возрастанию координаты x, а если x сравниваемых точек совпадают, то точки сравниваются по возрастанию координаты y. При таком упорядочивании выметающая прямая является вертикальной и движется слева направо вдоль оси x, определяя пересечения с отрезками множества L.

В каждый момент времени выметающая прямая SL пересекает только те отрезки, концы которых находятся по разные стороны от прямой. Выметающая прямая обновляет список пересекаемых отрезков в следующих случаях:
- когда прямая пересекает левый конец отрезка, отрезок добавляется в список
- когда прямая пересекает правый конец отрезка, отрезок удаляется из списка
Отрезки в списке расположены в порядке "выше-ниже" относительно прямой SL. Вставка и удаление отрезка из списка выполняется в худшем случае за O(logn), если использовать бинарный поиск. Кроме операций вставки и удаления, список отрезков также меняется при обнаружении точки пересечения отрезков: когда отрезки пересекаются, они должны поменяться местами в списке. Эта операция выполняется за O(logn).

Для организации списка отрезков алгоритм использует упорядоченную "очередь событий" EQ, элементы которой вызывают изменения в списке отрезков выметающей прямой SL. Первоначально EQ является упорядоченным списком конечных точек всех отрезков. Однако при обнаружении точек пересечений отрезков, эти точки также добавляются в EQ в том же порядке, в котором отсортированы концы отрезков. Однако надо избегать повторного добавления точек пересечения в очередь.

Однако как эффективно организовать нахождение всех точек пересечений? Когда отрезки последовательно добавляются в список SL, определяются их возможные пересечения с подходящими отрезками. Когда находится верная точка пересечения, она добавляется в очередь EQ. Далее, в момент, когда выметающая прямая достигнет точки пересечения, порядок пересекающихся отрезков в SL меняется, а точка пересечения добавляется в выходной список I. После работы алгоритма, когда все точки пересечения будут найдены, I будет содержать сортированное множество всех точек пересечений.

Однако ядро алгоритма ещше не описано, в частности, нужно ответить на вопрос, как именно алгоритм находит верное пересечение? Очевидно, два отрезка могут пересечься только тогда, когда они одновременно пересекаются выметающей прямой. Однако нахождение точек пересечения среди потенциально пересекающихся отрезков из списка SL не является эффективным алгоритмом (оно требует On2). Важнейшим наблюдением является тот факт, что пересекающиеся отрезки должны обязательно идти друг за другом в списке (быть соседями на выметающей прямой, один отрезок должен быть ровно под (или над) другим). Принимая во внимание это условие, число операций для определения пересечения сокращается:
1. Когда отрезок добавляется в SL, нужно определить, пересекается ли он с соседними отрезками сверху и снизу.
2. Когда отрезок удаляется из SL, его предыдущие соседи сверху и снизу становятся соседними, и требуется проверить их возможное пересечение.
3. В момент, когда SL достигает точки пересечения отрезков, их порядок в SL меняется, и каждый проверяется на пересечение с новым соседом (сверху или снизу).

Вышеперечисленные условия означают, что для обработки одного события (конечной точи отрезка или их пересечения) из EQ необходимо в худшем случае 2 проверки на пересечение.

Остается нерассмотренной одна деталь: время, которое необходимо потратить на добавление, поиск, изменение позиции и удаление отрезков из SL. Если размещать отрезки в сбалансированном двоичном дереве поиска (avl-дерево, 2,3-дерево или красно-черное дерево), эти операции можно выполнять за O(logn), где n - количество отрезков в SL. Если прибавить первоначальную сортировку и обработку событий, итоговая эффективность алгоритма выражается в O((n + k)logn), где k - количество найденных точек пересечения.

Следующий пседокод домонстрирует логику алгоритма:


`    Initialize event queue EQ = all segment endpoints;
    Sort EQ by increasing x and y;
    Initialize sweep line SL to be empty;
    Initialize output intersection list IL to be empty;

    While (EQ is nonempty) {
        Let E = the next event from EQ;
        If (E is a left endpoint) {
            Let segE = E's segment;
            Add segE to SL;
            Let segA = the segment Above segE in SL;
            Let segB = the segment Below segE in SL;
            If (I = Intersect( segE with segA) exists)
                Insert I into EQ;
            If (I = Intersect( segE with segB) exists)
                Insert I into EQ;
        }
        Else If (E is a right endpoint) {
            Let segE = E's segment;
            Let segA = the segment Above segE in SL;
            Let segB = the segment Below segE in SL;
            Delete segE from SL;
            If (I = Intersect( segA with segB) exists)
                If (I is not in EQ already)
                    Insert I into EQ;
        }
        Else {  // E is an intersection event
            Add E’s intersect point to the output list IL;
            Let segE1 above segE2 be E's intersecting segments in SL;
            Swap their positions so that segE2 is now above segE1;
            Let segA = the segment above segE2 in SL;
            Let segB = the segment below segE1 in SL;
            If (I = Intersect(segE2 with segA) exists)
                If (I is not in EQ already)
                    Insert I into EQ;
            If (I = Intersect(segE1 with segB) exists)
                If (I is not in EQ already)
                    Insert I into EQ;
        }
        remove E from EQ;
    }
    return IL;
}`
